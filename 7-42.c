/*
7-42 整除光棍 （20 分）
这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，
比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。
比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一
定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示
x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,
题目要求你输出最小的解。

提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在
于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681
和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。

输入格式：
输入在一行中给出一个不以5结尾的正奇数x（<1000）。

输出格式：
在一行中输出相应的最小的s和n，其间以1个空格分隔。

输入样例：
31
输出样例：
3584229390681 15
*/
#include <stdio.h>

int DIGITS = 256;                           // 256*6>1000 确保有解


void division(int z[256], int x, int y[256])
{   // 求商
    int red=0, temp=0, is_head=1;
    for (int i=0; i< DIGITS && z[i] > 0; i++)
    {   
        red = red * 1000000;                // 进位
        temp = (z[i] + red) / x;
        red = (z[i] + red) % x;
        y[i] = temp;
        if (i != 0 || temp > 0)
        {   
            if (is_head)
            {
                printf("%d", temp);
                is_head = 0;
            }
            else
                printf("%06d", temp);       // 防止中间位数缺零
        }
    }
}



int main() 
{   
    int n=1, x, y[DIGITS], z[DIGITS], temp=0;
    for(int i=0; i< DIGITS; i++)
    {
        z[i] = 0;
        y[i] = -1;
    }
    z[0] = 1;
    scanf("%d", &x);
    for(; n<6 * DIGITS; n++)
    {   
        temp *= 10;
        temp ++;
        if (temp % x == 0)
            break;
        else
            temp = temp % x;                // 迭代余数
        if (n % 6 != 0)
        {                                   // 高位递增一位
            z[0] *= 10;
            z[0] ++;
        }
        else
        {
            z[0] = 1;                       // 高位重置为1 扩展一个低位为111111
            z[n / 6] = 111111;
        }
    }
    division(z, x, y);
    printf(" %d", n);
    return 0;
}
